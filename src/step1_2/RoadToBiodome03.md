# RoadToBiodome03
* 작성자 : 전승현

### 목차
### 시간 복잡도의 정의와 필요성
컴퓨터 프로그램의 입력값과 연산 수행 시간의 상관관계를 나타내는 척도<br>
간단하게 정의하면 알고리즘의 성능을 설명하는것.<br>
알고리즘을 수행하기위해 프로세스가 수행하는 연산을 수치화한 것이다. <br>
주로 Big O 표기법을 사용해 최악의 경우 실행시간을 나타낸다.
<br><br>
시간복잡도를 사용하는 이유는 다양한 알고리즘 중에 가장 효율적인 알고리즘을 찾아내서 더 빠른 실행시간을 기대할 수 있고<br>
시간복잡도를 이해함으로 써 코드의 비효율적인 부분을 찾아내고 이를 최적화 할 수 있습니다.


### Big O 표기법의 개념과 상황별 예시
##### 빅오 표기법(Big-O)
불필요한 연산을 제거하여 알고리즘분석을 쉽게 할 목적으로 사용된다.
Big-o로 측정되는 복잡성에는 시간과 공간복잡도가 있는데
- 시간 복잡도는 입력된 N의 크기에 따라 실행되는 조작의 수를 나타낸다.
- 공간복잡도는 알고리즘이 실행될때 사용하는 메모리의 양을 나타낸다.
  요즈음에는 데이터를 저장할 수 있는 메모리의 발전으로 중요도가 낮아졌다.

##### 시간복잡도

간단하게 정의하면 알고리즘의 성능을 설명하는것.<br>
알고리즘을 수행하기위해 프로세스가 수행하는 연산을 수치화한 것이다.

##### 예시1. O(1)

예) print()처럼 입력에 관계없는 복잡도는 동일하게 유지

##### 예시2. O(N) 선형

예)입력이 증가하면 처리 시간 또는 메모리 사용이 선형적으로 증가한다.

##### 예시3. O(N^2) : Square

예 ) 반복문이 두개 있는경우 (중첩반복도 포함)

##### 예시4. O(log n ) O(n log n)

예) 주로 입력크기에 따라 처리 시간이 증가하는 정렬알고리즘에서 사용


### 문제01 코드의 시간 복잡도 분석
제가 작성한 코드는 list를 순회하면서  각 숫자가 배열 내에 몇 번 등장하는지를 세고, 오직 한 번만 등장하는 숫자를 찾아 반환합니다.<br>
최악의 경우, 이 알고리즘은 각 숫자에 대해 전체 배열을 다시 순회해야 하므로, 이중 반복문의 형태를 띠게 됩니다.<br>
외부 반복문은 배열의 모든 요소 n에 대해 한 번씩 실행됩니다.<br>
내부 반복문은 각 외부 반복 실행에 대해 배열의 모든 요소 n에 대해 다시 한 번 실행됩니다.
<br>
따라서, 이중 반복문의 시간 복잡도는 O(n^2)로 계산됩니다. 여기서 n은 입력 배열 list의 길이입니다.
### 문제02 코드의 시간 복잡도 분석

palindrome 메서드는 문자열의 앞부분과 뒷부분을 비교하여 회문을 판별합니다. 이 메서드는 문자열의 길이를 n으로 할 때, 문자열의 절반 길이만큼 반복합니다.<br>
따라서, 이 메서드의 시간 복잡도는 O(n/2)이지만, 빅오 표기법에서 상수는 생략되므로 O(n)입니다.<br>
push 연산: 스택에 문자열의 각 문자를 추가하는 과정에서, 각 문자마다 한 번씩 push 연산이 실행됩니다. 문자열의 길이가 n일 때, 이 과정의 시간 복잡도는 O(n)입니다<br>
pop 연산: 스택에서 모든 요소를 꺼내어 출력하는 과정 역시 문자열의 길이가 n일 때, O(n)의 시간 복잡도를 가집니다.
### 병목 현상 분석 및 최적화 방안

#### 문제1 병목 현상 분석
중첩 반복문을 사용하여 각 요소의 등장 횟수를 세는 부분입니다. 배열의 크기가 n일 때, 이 로직의 시간 복잡도는 O(n^2)입니다.<br>
배열의 길이가 길어질수록 실행 시간이 기하급수적으로 증가하여, 이 부분이 성능을 크게 저하시키는 병목 지점입니다.

#### 문제1 최적화 방안
HashMap을 사용하여 각 숫자가 몇 번 나타나는지를 한 번의 순회로 계산할 수 있습니다.<br>
그 후, 다시 한 번 순회하면서 단 한 번만 나타난 숫자를 찾아 반환합니다. 이 방법은 두 번의 순회가 필요하지만,<br>
각 순회는 O(n)이므로 전체 시간 복잡도는 O(n)이 됩니다.


#### 문제 2 병목 현상 분석
문 검사 로직과 문자열 역순 출력 부분입니다. 두 부분 모두 O(n)의 시간 복잡도를 가지므로, 매우 큰 문자열을 처리할 때 성능 저하를 일으킬 수 있습니다.<br>
하지만, 각각의 작업은 최적화된 알고리즘을 사용하고 있으므로, 실제 병목 현상을 일으키는 주된 원인은 입력 데이터의 크기에 따라 달라질 수 있습니다.

##### 문제2 최적화 방안
 원래 ArrayList를 사용하여 stack을 구현하려 했지만, addFirst와 removeFirst 메서드들은 <br>
 ArrayList에 존재하지 않고 LinkedList에서 제공됩니다. ArrayList에서 제공하는 add(0, element)와 remove(0) 메서드를<br>
 사용해 처음 위치에 요소를 추가하거나 제거할 수는 있으나, 이러한 작업들은 ArrayList에서 O(n)의 시간 복잡도를 가지므로 비효율적입니다.<br>
 따라서, O(1)의 시간 복잡도로 요소를 추가하고 제거할 수 있는 LinkedList로 구현 방식을 변경하였습니다.<br>
 이는 전체적인 코드의 성능을 향상시키는 데 도움이 됩니다. (출처 : 뤼튼)


#### bonus 문제 
#### 문제 1 
기존의 중첩 반복을 사용하던 방법을 HashMap을 이용하여 배열을 한번만 순회하면
시간 복잡도가 O(n^2) 에서 o(n)이 됩니다.
#### 문제 2
최적화 방안과 내용이 동일합니다.